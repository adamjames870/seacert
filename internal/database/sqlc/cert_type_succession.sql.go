// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: cert_type_succession.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
)

const createTypeSuccession = `-- name: CreateTypeSuccession :one
INSERT INTO certificate_type_successions
    (id, replacing_cert_type, replaceable_cert_type, replace_reason)
VALUES
    ($1, $2, $3, $4)
RETURNING id, created_at, updated_at, replacing_cert_type, replaceable_cert_type, replace_reason
`

type CreateTypeSuccessionParams struct {
	ID                  uuid.UUID
	ReplacingCertType   uuid.UUID
	ReplaceableCertType uuid.UUID
	ReplaceReason       SuccessionReason
}

func (q *Queries) CreateTypeSuccession(ctx context.Context, arg CreateTypeSuccessionParams) (CertificateTypeSuccession, error) {
	row := q.db.QueryRowContext(ctx, createTypeSuccession,
		arg.ID,
		arg.ReplacingCertType,
		arg.ReplaceableCertType,
		arg.ReplaceReason,
	)
	var i CertificateTypeSuccession
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ReplacingCertType,
		&i.ReplaceableCertType,
		&i.ReplaceReason,
	)
	return i, err
}

const deleteTypeSuccession = `-- name: DeleteTypeSuccession :exec
DELETE FROM certificate_type_successions
WHERE id = $1
`

func (q *Queries) DeleteTypeSuccession(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteTypeSuccession, id)
	return err
}

const getAllReplaceableByMe = `-- name: GetAllReplaceableByMe :many
SELECT
    succession.id, type.id, type.name, succession.replace_reason
FROM
    certificate_types type
INNER JOIN
    certificate_type_successions succession
ON
    succession.replacing_cert_type = type.id
WHERE
    succession.replacing_cert_type = $1
`

type GetAllReplaceableByMeRow struct {
	ID            uuid.UUID
	ID_2          uuid.UUID
	Name          string
	ReplaceReason SuccessionReason
}

func (q *Queries) GetAllReplaceableByMe(ctx context.Context, replacingCertType uuid.UUID) ([]GetAllReplaceableByMeRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllReplaceableByMe, replacingCertType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllReplaceableByMeRow
	for rows.Next() {
		var i GetAllReplaceableByMeRow
		if err := rows.Scan(
			&i.ID,
			&i.ID_2,
			&i.Name,
			&i.ReplaceReason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllThatCanReplaceMe = `-- name: GetAllThatCanReplaceMe :many
SELECT
    succession.id, type.id, type.name, succession.replace_reason
FROM
    certificate_types type
        INNER JOIN
    certificate_type_successions succession
    ON
        succession.replaceable_cert_type = type.id
WHERE
    succession.replaceable_cert_type = $1
`

type GetAllThatCanReplaceMeRow struct {
	ID            uuid.UUID
	ID_2          uuid.UUID
	Name          string
	ReplaceReason SuccessionReason
}

func (q *Queries) GetAllThatCanReplaceMe(ctx context.Context, replaceableCertType uuid.UUID) ([]GetAllThatCanReplaceMeRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllThatCanReplaceMe, replaceableCertType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllThatCanReplaceMeRow
	for rows.Next() {
		var i GetAllThatCanReplaceMeRow
		if err := rows.Scan(
			&i.ID,
			&i.ID_2,
			&i.Name,
			&i.ReplaceReason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReplaceSuccessions = `-- name: GetReplaceSuccessions :many
SELECT
    succession.id, type.id, type.name
FROM
    certificate_types type
INNER JOIN
    certificate_type_successions succession
ON
    succession.replacing_cert_type = type.id
WHERE
    succession.replaceable_cert_type = $1
AND
    succession.replace_reason = 'replaced'
`

type GetReplaceSuccessionsRow struct {
	ID   uuid.UUID
	ID_2 uuid.UUID
	Name string
}

func (q *Queries) GetReplaceSuccessions(ctx context.Context, replaceableCertType uuid.UUID) ([]GetReplaceSuccessionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getReplaceSuccessions, replaceableCertType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReplaceSuccessionsRow
	for rows.Next() {
		var i GetReplaceSuccessionsRow
		if err := rows.Scan(&i.ID, &i.ID_2, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUpdateSuccessions = `-- name: GetUpdateSuccessions :many
SELECT
    succession.id, type.id, type.name
FROM
    certificate_types type
INNER JOIN
    certificate_type_successions succession
ON
    succession.replacing_cert_type = type.id
WHERE
    succession.replaceable_cert_type = $1
AND
    succession.replace_reason = 'updated'
`

type GetUpdateSuccessionsRow struct {
	ID   uuid.UUID
	ID_2 uuid.UUID
	Name string
}

func (q *Queries) GetUpdateSuccessions(ctx context.Context, replaceableCertType uuid.UUID) ([]GetUpdateSuccessionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUpdateSuccessions, replaceableCertType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUpdateSuccessionsRow
	for rows.Next() {
		var i GetUpdateSuccessionsRow
		if err := rows.Scan(&i.ID, &i.ID_2, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
